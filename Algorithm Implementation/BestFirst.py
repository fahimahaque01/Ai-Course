import heapq  # priority queue ржмрзНржпржмрж╣рж╛рж░рзЗрж░ ржЬржирзНржп

def best_first_search(graph, start, goal, heuristic):
    visited = set()  # ржпрзЗрж╕ржм node ржЖржорж░рж╛ ржЖржЧрзЗржЗ ржжрзЗржЦрзЗ ржлрзЗрж▓рзЗржЫрж┐
    queue = [(heuristic[start], start)]  # priority queue (min-heap)

    while queue:
        _, current = heapq.heappop(queue)  # heuristic ржорж╛ржи рж╕ржмржЪрзЗрзЯрзЗ ржХржо ржпрзЗржЯрж╛, ржУржЯрж╛ ржмрзЗрж░ ржХрж░рж┐
        print("Visiting:", current)

        if current == goal:
            print("ЁЯОп Goal reached:", current)
            return

        if current not in visited:
            visited.add(current)
            for neighbor in graph[current]:
                if neighbor not in visited:
                    heapq.heappush(queue, (heuristic[neighbor], neighbor))

    print("тЭМ Goal not found")

# ЁЯФН ржЧрзНрж░рж╛ржл (adjacency list ржЖржХрж╛рж░рзЗ)
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['G'],
    'F': [],
    'G': []
}

# ЁЯОп heuristic ржорж╛ржи (ржпржд ржЫрзЛржЯ, рждржд ржнрж╛рж▓рзЛ)
heuristic = {
    'A': 6,
    'B': 4,
    'C': 5,
    'D': 2,
    'E': 3,
    'F': 6,
    'G': 0  # goal node
}

# тЦ╢я╕П function call
best_first_search(graph, 'A', 'G', heuristic)

# ржЧрзНрж░рж╛ржл
graph = {
    'A': ['B', 'C'],
    'B': ['D'],
    'C': [],
    'D': []
}

# heuristic values (goal: D)
heuristic = {
    'A': 3,
    'B': 2,
    'C': 4,
    'D': 0
}

best_first_search(graph, 'A', 'D', heuristic)

def best_first_search(...)
ржПржЦрж╛ржирзЗ ржЖржорж░рж╛ ржЖржорж╛ржжрзЗрж░ ржорзВрж▓ function ржмрж╛ржирж╛ржЪрзНржЫрж┐ тАФ рзкржЯрж╛ ржЗржиржкрзБржЯ ржирж┐ржЪрзНржЫрзЗ:

graph тЖТ ржЧрзНрж░рж╛ржлржЯрж╛ (node ржЧрзБрж▓рзЛрж░ рж╕ржВржпрзЛржЧ)

start тЖТ ржХрзЛржерж╛ ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░ржм

goal тЖТ ржЧржирзНрждржмрзНржп ржХрзЛржерж╛рзЯ

heuristic тЖТ ржХрзЛржи node goal ржерзЗржХрзЗ ржХрждржЯрж╛ ржжрзВрж░рзЗ, рж╕рзЗржЗ ржзрж╛рж░ржгрж╛


тЬЕ visited = set()
ржпрзЗрж╕ржм node ржЖржорж░рж╛ ржЖржЧрзЗржЗ ржШрж╛ржБржЯрзЗржЫрж┐, рж╕рзЗржЧрзБрж▓рж╛ ржПржЗ visited рж╕рзЗржЯрзЗ рж░рж╛ржЦржм тАФ ржпрж╛рждрзЗ ржмрж╛рж░ржмрж╛рж░ ржПржХржЗ ржЬрж╛рзЯржЧрж╛рзЯ ржирж╛ ржпрж╛ржЗред

queue = [(heuristic[start], start)]
ржЖржорж╛ржжрзЗрж░ priority queue рж╢рзБрж░рзБ рж╣ржЪрзНржЫрзЗ тАФ ржпрж╛рж░ ржкрзНрж░ржержо ржорж╛ржи start node ржЖрж░ рждрж╛рж░ heuristic ржорж╛ржиред

ЁЯСЙ ржПржЯрж╛ ржорж┐ржи-рж╣рж┐ржкрзЗрж░ ржорждрзЛ ржХрж╛ржЬ ржХрж░рзЗ, ржорж╛ржирзЗ ржпрзЗржЯрж╛рж░ ржорж╛ржи (distance) рж╕ржмржЪрзЗрзЯрзЗ ржХржо, ржУржЯрж╛ржХрзЗржЗ ржЖржЧрзЗ ржмрзЗрж░ ржХрж░ржмрзЗред


 while queue:
ржпрждржХрзНрж╖ржг queue-рждрзЗ ржХрж┐ржЫрзБ ржЖржЫрзЗ, ржЖржорж░рж╛ ржПржХрзЗ ржПржХрзЗ node ржмрзЗрж░ ржХрж░рзЗ ржШрж╛ржБржЯржмред

ржПржЦрж╛ржирзЗ queue ржерзЗржХрзЗ heuristic ржорж╛ржи ржЕржирзБржпрж╛рзЯрзА рж╕рж░рзНржмрзЛрждрзНрждржо (рж╕рж░рзНржмржирж┐ржорзНржи ржорж╛ржиржУрзЯрж╛рж▓рж╛) node ржЯрж╛ ржмрзЗрж░ ржХрж░рзЗ ржЖржиржЫрж┐ред

if current == goal:
ржпржжрж┐ ржПржЦржи ржпрзЗ node ржЯрж╛ ржжрзЗржЦржЫрж┐, ржУржЯрж╛ржЗ ржЧржирзНрждржмрзНржп рж╣рзЯ тАФ рждрж╛рж╣рж▓рзЗ ржЦрзЛржБржЬрж╛ рж╢рзЗрж╖!


 if current not in visited:
ржпржжрж┐ node ржЯрж╛ ржПржЦржирзЛ ржЖржорж░рж╛ ржШрж╛ржБржЯрж┐ржирж┐, рждрж╛рж╣рж▓рзЗ:

тЬЕ visited.add(current) тЖТ ржШрж╛ржБржЯрж╛ рж╣рзЯрзЗ ржЧрзЗржЫрзЗ, ржмрж▓рзЗ рж░рж╛ржЦрж┐ред

тЬЕ for neighbor in graph[current] тЖТ ржПрж░ ржкрзНрж░рждрж┐ржмрзЗрж╢рж┐ node ржЧрзБрж▓рж╛ ржШрж╛ржБржЯрж┐

тЬЕ heapq.heappush(...) тЖТ neighbor ржЧрзБрж▓рж╛ queue рждрзЗ ржврзБржХрж┐рзЯрзЗ ржжрзЗржЗ, ржУржжрзЗрж░ heuristic ржЕржирзБржпрж╛рзЯрзАред


